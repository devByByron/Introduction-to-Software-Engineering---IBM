# Introduction-to-Software-Engineering - IBM

Course Structure Overview
The course is organized into five modules:

The Software Development Lifecycle

Introduction to Software Development

Basics of Programming

Software Architecture, Design, and Patterns

Job Opportunities and Skillsets in Software Engineering


What is Software Engineering?

Definition: Applying scientific principles to design, build, and test software systematically.

Purpose: Collect and analyze business requirements → create reliable software solutions.

History & Evolution

1950s–1960s: Software development was ad hoc, with no formal process.

1960s–1980s: “Software Crisis” — projects ran over budget, behind schedule, and produced buggy, unscalable code.

Solution: Introduce engineering discipline → structured methods, CASE (Computer-Aided Software Engineering) tools.

CASE Tools Categories:

Business analysis & modeling

Development tools (e.g., debugging)

Verification & validation

Configuration management

Metrics & measurement

Project management

Software Engineer vs. Software Developer

Software Engineer:

Broader scope, system-level focus

Designs, builds, maintains whole systems

Responsibilities: writing/testing code, consulting with clients, vendors, security specialists, and team members

Works mainly on large-scale projects

Software Developer:

Narrower focus, implements specific functionality

Often more creative problem-solving on smaller parts of the system

Key Difference: Engineers = big-picture/system-wide approach; Developers = code/functionality focus.

Modern Practices

Guided by Software Development Lifecycle (SDLC) to ensure quality and scalability.

SDLC = structured phases to build high-quality software.

**Phases of the Software Development Life Cycle (SDLC)**

<img width="241" height="283" alt="image" src="https://github.com/user-attachments/assets/dcde7e75-52b1-4b2d-829a-21aa5923d114" />


Planning Phase

Requirements are gathered, analyzed, documented, and prioritized.
Factors such as user needs, project purpose, compliance, and resource allocation are considered.
Design Phase

The software architecture is developed based on the requirements from the Software Requirements Specification (SRS).
Prototypes may be created for demonstration and feedback, and a design document is produced for developers.
Development Phase

Coding begins once the design document is completed, with tasks assigned to developers.
Various programming tools and languages are utilized, adhering to organizational standards.
Testing Phase

Code is thoroughly tested to ensure stability, security, and compliance with the SRS.
Different testing levels, such as unit and integration testing, are conducted to identify and fix bugs.
Deployment Phase

The application is released into the production environment, often in stages.
User acceptance testing (UAT) is performed before final release to ensure functionality.
Maintenance Phase

Post-deployment, the software is monitored for bugs and user interface issues.
Feedback is collected for future enhancements, and the cycle may restart as needed.

**Building Quality Software – Key Points**
1. Requirements Gathering

Collect and document everything the software must do.

Stored in an SRS (Software Requirements Specification).

Categories of requirements:

Functional (what it does)

UI / external requirements

System features

Non-functional (performance, security, etc.)

2. Design

Turns requirements into a blueprint developers can code.

Defines system architecture: components, their roles, and how they interact.

Includes: business rules, APIs, UI design, database design, performance, and security.

3. Coding for Quality

Write clean, consistent, maintainable, and secure code.

Practices:

Follow coding standards & patterns

Use linters (tools that detect style or code issues)

Add meaningful comments

Goal: Code that meets requirements, is easy to read, test, and maintain.

4. Testing

Verifies software matches requirements and is bug-free.

Ensures reliability, performance, and security.

Levels of testing:

Unit (smallest pieces, by developers)

Integration (how components work together)

System (whole product)

User Acceptance / Beta testing (by end users)

Types of testing: Functional, Non-functional, Regression.

5. Releases

Versions of software given to users:

Alpha → early version for internal stakeholders, incomplete and buggy.

Beta → for external stakeholders, functional but still tested in real conditions.

GA (General Availability) → final, stable release for all users.

6. Documentation

Explains how to use and maintain the software.

System documentation (for technical users): architecture, design, code comments, guides.

User documentation (for non-technical users): manuals, help files, videos, tutorials.


